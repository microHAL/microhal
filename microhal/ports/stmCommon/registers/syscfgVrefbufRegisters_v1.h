#ifndef _MICROHAL_PERIPHERAL_REGISTER_SYSCFG_VREFBUF
#define _MICROHAL_PERIPHERAL_REGISTER_SYSCFG_VREFBUF

#include "registersBaseAddressDefinitions.h"
#include "utils/bitfield.h"
#include "utils/volatileRegister.h"

// Supported MCU: STM32G071, STM32G070, STM32G081, STM32G071, STM32G070, STM32G081
namespace microhal {
namespace registers {
/**
 *
 */
struct SYSCFG_VREFBUF {
    // VREFBUF control and status register
    union VREFBUF_CSR {
        union {
            microhal::Bitfield<uint32_t, 0, 1>
                ENVR; /*!< Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode. */
            microhal::Bitfield<uint32_t, 1, 1>
                HIZ; /*!< High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer
                        modes for the mode descriptions depending on ENVR bit configuration. */
            microhal::Bitfield<uint32_t, 3, 1> VRR; /*!< Voltage reference buffer ready */
            microhal::Bitfield<uint32_t, 4, 3>
                VRS; /*!< Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        VREFBUF_CSR &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        VREFBUF_CSR &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        VREFBUF_CSR &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        VREFBUF_CSR operator&(uint32_t value) const {
            VREFBUF_CSR tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        VREFBUF_CSR operator|(uint32_t value) const {
            VREFBUF_CSR tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<VREFBUF_CSR, AccessType::ReadOnly>;
        friend class VolatileRegister<VREFBUF_CSR, AccessType::WriteOnly>;
        friend class VolatileRegister<VREFBUF_CSR, AccessType::ReadWrite>;
    };

    // VREFBUF calibration control register
    union VREFBUF_CCR {
        union {
            microhal::Bitfield<uint32_t, 0, 6>
                TRIM; /*!< Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory
                         during the production test. Writing into these bits allows to tune the internal reference buffer voltage. */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        VREFBUF_CCR &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        VREFBUF_CCR &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        VREFBUF_CCR &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        VREFBUF_CCR operator&(uint32_t value) const {
            VREFBUF_CCR tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        VREFBUF_CCR operator|(uint32_t value) const {
            VREFBUF_CCR tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<VREFBUF_CCR, AccessType::ReadOnly>;
        friend class VolatileRegister<VREFBUF_CCR, AccessType::WriteOnly>;
        friend class VolatileRegister<VREFBUF_CCR, AccessType::ReadWrite>;
    };

    // SYSCFG configuration register 1
    union CFGR1 {
        union {
            microhal::Bitfield<uint32_t, 0, 2> MEM_MODE;      /*!< Memory mapping selection bits */
            microhal::Bitfield<uint32_t, 4, 1> PA11_PA12_RMP; /*!< PA11 and PA12 remapping bit. */
            microhal::Bitfield<uint32_t, 5, 1> IR_POL;        /*!< IR output polarity selection */
            microhal::Bitfield<uint32_t, 6, 2> IR_MOD;        /*!< IR Modulation Envelope signal selection. */
            microhal::Bitfield<uint32_t, 8, 1> BOOSTEN;       /*!< I/O analog switch voltage booster enable */
            microhal::Bitfield<uint32_t, 9, 1> UCPD1_STROBE;  /*!< Strobe signal bit for UCPD1 */
            microhal::Bitfield<uint32_t, 10, 1> UCPD2_STROBE; /*!< Strobe signal bit for UCPD2 */
            microhal::Bitfield<uint32_t, 16, 4> I2C_PBx_FMP;  /*!< Fast Mode Plus (FM+) driving capability activation bits */
            microhal::Bitfield<uint32_t, 20, 1> I2C1_FMP;     /*!< FM+ driving capability activation for I2C1 */
            microhal::Bitfield<uint32_t, 21, 1> I2C2_FMP;     /*!< FM+ driving capability activation for I2C2 */
            microhal::Bitfield<uint32_t, 22, 2> I2C_PAx_FMP;  /*!< Fast Mode Plus (FM+) driving capability activation bits */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        CFGR1 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        CFGR1 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        CFGR1 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        CFGR1 operator&(uint32_t value) const {
            CFGR1 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        CFGR1 operator|(uint32_t value) const {
            CFGR1 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<CFGR1, AccessType::ReadOnly>;
        friend class VolatileRegister<CFGR1, AccessType::WriteOnly>;
        friend class VolatileRegister<CFGR1, AccessType::ReadWrite>;
    };

    // SYSCFG configuration register 1
    union CFGR2 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> LOCKUP_LOCK;      /*!< Cortex-M0+ LOCKUP bit enable bit */
            microhal::Bitfield<uint32_t, 1, 1> SRAM_PARITY_LOCK; /*!< SRAM parity lock bit */
            microhal::Bitfield<uint32_t, 2, 1> PVD_LOCK;         /*!< PVD lock enable bit */
            microhal::Bitfield<uint32_t, 3, 1> ECC_LOCK;         /*!< ECC error lock bit */
            microhal::Bitfield<uint32_t, 8, 1> SRAM_PEF;         /*!< SRAM parity error flag */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        CFGR2 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        CFGR2 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        CFGR2 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        CFGR2 operator&(uint32_t value) const {
            CFGR2 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        CFGR2 operator|(uint32_t value) const {
            CFGR2 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<CFGR2, AccessType::ReadOnly>;
        friend class VolatileRegister<CFGR2, AccessType::WriteOnly>;
        friend class VolatileRegister<CFGR2, AccessType::ReadWrite>;
    };

    // interrupt line 0 status register
    union ITLINE0 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> WWDG; /*!< Window watchdog interrupt pending flag */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE0 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE0 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE0 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE0 operator&(uint32_t value) const {
            ITLINE0 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE0 operator|(uint32_t value) const {
            ITLINE0 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE0, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE0, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE0, AccessType::ReadWrite>;
    };

    // interrupt line 1 status register
    union ITLINE1 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> PVDOUT; /*!< PVD supply monitoring interrupt request pending (EXTI line 16). */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE1 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE1 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE1 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE1 operator&(uint32_t value) const {
            ITLINE1 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE1 operator|(uint32_t value) const {
            ITLINE1 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE1, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE1, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE1, AccessType::ReadWrite>;
    };

    // interrupt line 2 status register
    union ITLINE2 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TAMP; /*!< TAMP */
            microhal::Bitfield<uint32_t, 1, 1> RTC;  /*!< RTC */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE2 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE2 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE2 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE2 operator&(uint32_t value) const {
            ITLINE2 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE2 operator|(uint32_t value) const {
            ITLINE2 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE2, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE2, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE2, AccessType::ReadWrite>;
    };

    // interrupt line 3 status register
    union ITLINE3 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> FLASH_ITF; /*!< FLASH_ITF */
            microhal::Bitfield<uint32_t, 1, 1> FLASH_ECC; /*!< FLASH_ECC */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE3 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE3 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE3 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE3 operator&(uint32_t value) const {
            ITLINE3 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE3 operator|(uint32_t value) const {
            ITLINE3 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE3, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE3, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE3, AccessType::ReadWrite>;
    };

    // interrupt line 4 status register
    union ITLINE4 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> RCC; /*!< RCC */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE4 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE4 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE4 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE4 operator&(uint32_t value) const {
            ITLINE4 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE4 operator|(uint32_t value) const {
            ITLINE4 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE4, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE4, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE4, AccessType::ReadWrite>;
    };

    // interrupt line 5 status register
    union ITLINE5 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> EXTI0; /*!< EXTI0 */
            microhal::Bitfield<uint32_t, 1, 1> EXTI1; /*!< EXTI1 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE5 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE5 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE5 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE5 operator&(uint32_t value) const {
            ITLINE5 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE5 operator|(uint32_t value) const {
            ITLINE5 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE5, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE5, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE5, AccessType::ReadWrite>;
    };

    // interrupt line 6 status register
    union ITLINE6 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> EXTI2; /*!< EXTI2 */
            microhal::Bitfield<uint32_t, 1, 1> EXTI3; /*!< EXTI3 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE6 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE6 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE6 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE6 operator&(uint32_t value) const {
            ITLINE6 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE6 operator|(uint32_t value) const {
            ITLINE6 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE6, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE6, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE6, AccessType::ReadWrite>;
    };

    // interrupt line 7 status register
    union ITLINE7 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> EXTI4;   /*!< EXTI4 */
            microhal::Bitfield<uint32_t, 1, 1> EXTI5;   /*!< EXTI5 */
            microhal::Bitfield<uint32_t, 2, 1> EXTI6;   /*!< EXTI6 */
            microhal::Bitfield<uint32_t, 3, 1> EXTI7;   /*!< EXTI7 */
            microhal::Bitfield<uint32_t, 4, 1> EXTI8;   /*!< EXTI8 */
            microhal::Bitfield<uint32_t, 5, 1> EXTI9;   /*!< EXTI9 */
            microhal::Bitfield<uint32_t, 6, 1> EXTI10;  /*!< EXTI10 */
            microhal::Bitfield<uint32_t, 7, 1> EXTI11;  /*!< EXTI11 */
            microhal::Bitfield<uint32_t, 8, 1> EXTI12;  /*!< EXTI12 */
            microhal::Bitfield<uint32_t, 9, 1> EXTI13;  /*!< EXTI13 */
            microhal::Bitfield<uint32_t, 10, 1> EXTI14; /*!< EXTI14 */
            microhal::Bitfield<uint32_t, 11, 1> EXTI15; /*!< EXTI15 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE7 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE7 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE7 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE7 operator&(uint32_t value) const {
            ITLINE7 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE7 operator|(uint32_t value) const {
            ITLINE7 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE7, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE7, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE7, AccessType::ReadWrite>;
    };

    // interrupt line 8 status register
    union ITLINE8 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> UCPD1; /*!< UCPD1 */
            microhal::Bitfield<uint32_t, 1, 1> UCPD2; /*!< UCPD2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE8 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE8 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE8 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE8 operator&(uint32_t value) const {
            ITLINE8 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE8 operator|(uint32_t value) const {
            ITLINE8 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE8, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE8, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE8, AccessType::ReadWrite>;
    };

    // interrupt line 9 status register
    union ITLINE9 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> DMA1_CH1; /*!< DMA1_CH1 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE9 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE9 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE9 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE9 operator&(uint32_t value) const {
            ITLINE9 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE9 operator|(uint32_t value) const {
            ITLINE9 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE9, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE9, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE9, AccessType::ReadWrite>;
    };

    // interrupt line 10 status register
    union ITLINE10 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> DMA1_CH2; /*!< DMA1_CH1 */
            microhal::Bitfield<uint32_t, 1, 1> DMA1_CH3; /*!< DMA1_CH3 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE10 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE10 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE10 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE10 operator&(uint32_t value) const {
            ITLINE10 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE10 operator|(uint32_t value) const {
            ITLINE10 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE10, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE10, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE10, AccessType::ReadWrite>;
    };

    // interrupt line 11 status register
    union ITLINE11 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> DMAMUX;   /*!< DMAMUX */
            microhal::Bitfield<uint32_t, 1, 1> DMA1_CH4; /*!< DMA1_CH4 */
            microhal::Bitfield<uint32_t, 2, 1> DMA1_CH5; /*!< DMA1_CH5 */
            microhal::Bitfield<uint32_t, 3, 1> DMA1_CH6; /*!< DMA1_CH6 */
            microhal::Bitfield<uint32_t, 4, 1> DMA1_CH7; /*!< DMA1_CH7 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE11 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE11 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE11 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE11 operator&(uint32_t value) const {
            ITLINE11 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE11 operator|(uint32_t value) const {
            ITLINE11 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE11, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE11, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE11, AccessType::ReadWrite>;
    };

    // interrupt line 12 status register
    union ITLINE12 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> ADC;   /*!< ADC */
            microhal::Bitfield<uint32_t, 1, 1> COMP1; /*!< COMP1 */
            microhal::Bitfield<uint32_t, 2, 1> COMP2; /*!< COMP2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE12 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE12 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE12 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE12 operator&(uint32_t value) const {
            ITLINE12 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE12 operator|(uint32_t value) const {
            ITLINE12 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE12, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE12, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE12, AccessType::ReadWrite>;
    };

    // interrupt line 13 status register
    union ITLINE13 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM1_CCU; /*!< TIM1_CCU */
            microhal::Bitfield<uint32_t, 1, 1> TIM1_TRG; /*!< TIM1_TRG */
            microhal::Bitfield<uint32_t, 2, 1> TIM1_UPD; /*!< TIM1_UPD */
            microhal::Bitfield<uint32_t, 3, 1> TIM1_BRK; /*!< TIM1_BRK */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE13 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE13 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE13 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE13 operator&(uint32_t value) const {
            ITLINE13 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE13 operator|(uint32_t value) const {
            ITLINE13 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE13, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE13, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE13, AccessType::ReadWrite>;
    };

    // interrupt line 14 status register
    union ITLINE14 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM1_CC; /*!< TIM1_CC */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE14 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE14 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE14 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE14 operator&(uint32_t value) const {
            ITLINE14 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE14 operator|(uint32_t value) const {
            ITLINE14 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE14, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE14, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE14, AccessType::ReadWrite>;
    };

    // interrupt line 15 status register
    union ITLINE15 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM2; /*!< TIM2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE15 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE15 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE15 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE15 operator&(uint32_t value) const {
            ITLINE15 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE15 operator|(uint32_t value) const {
            ITLINE15 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE15, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE15, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE15, AccessType::ReadWrite>;
    };

    // interrupt line 16 status register
    union ITLINE16 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM3; /*!< TIM3 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE16 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE16 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE16 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE16 operator&(uint32_t value) const {
            ITLINE16 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE16 operator|(uint32_t value) const {
            ITLINE16 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE16, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE16, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE16, AccessType::ReadWrite>;
    };

    // interrupt line 17 status register
    union ITLINE17 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM6;   /*!< TIM6 */
            microhal::Bitfield<uint32_t, 1, 1> DAC;    /*!< DAC */
            microhal::Bitfield<uint32_t, 2, 1> LPTIM1; /*!< LPTIM1 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE17 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE17 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE17 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE17 operator&(uint32_t value) const {
            ITLINE17 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE17 operator|(uint32_t value) const {
            ITLINE17 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE17, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE17, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE17, AccessType::ReadWrite>;
    };

    // interrupt line 18 status register
    union ITLINE18 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM7;   /*!< TIM7 */
            microhal::Bitfield<uint32_t, 1, 1> LPTIM2; /*!< LPTIM2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE18 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE18 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE18 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE18 operator&(uint32_t value) const {
            ITLINE18 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE18 operator|(uint32_t value) const {
            ITLINE18 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE18, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE18, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE18, AccessType::ReadWrite>;
    };

    // interrupt line 19 status register
    union ITLINE19 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM14; /*!< TIM14 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE19 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE19 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE19 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE19 operator&(uint32_t value) const {
            ITLINE19 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE19 operator|(uint32_t value) const {
            ITLINE19 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE19, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE19, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE19, AccessType::ReadWrite>;
    };

    // interrupt line 20 status register
    union ITLINE20 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM15; /*!< TIM15 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE20 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE20 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE20 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE20 operator&(uint32_t value) const {
            ITLINE20 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE20 operator|(uint32_t value) const {
            ITLINE20 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE20, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE20, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE20, AccessType::ReadWrite>;
    };

    // interrupt line 21 status register
    union ITLINE21 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM16; /*!< TIM16 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE21 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE21 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE21 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE21 operator&(uint32_t value) const {
            ITLINE21 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE21 operator|(uint32_t value) const {
            ITLINE21 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE21, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE21, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE21, AccessType::ReadWrite>;
    };

    // interrupt line 22 status register
    union ITLINE22 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> TIM17; /*!< TIM17 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE22 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE22 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE22 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE22 operator&(uint32_t value) const {
            ITLINE22 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE22 operator|(uint32_t value) const {
            ITLINE22 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE22, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE22, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE22, AccessType::ReadWrite>;
    };

    // interrupt line 23 status register
    union ITLINE23 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> I2C1; /*!< I2C1 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE23 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE23 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE23 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE23 operator&(uint32_t value) const {
            ITLINE23 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE23 operator|(uint32_t value) const {
            ITLINE23 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE23, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE23, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE23, AccessType::ReadWrite>;
    };

    // interrupt line 24 status register
    union ITLINE24 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> I2C2; /*!< I2C2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE24 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE24 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE24 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE24 operator&(uint32_t value) const {
            ITLINE24 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE24 operator|(uint32_t value) const {
            ITLINE24 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE24, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE24, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE24, AccessType::ReadWrite>;
    };

    // interrupt line 25 status register
    union ITLINE25 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> SPI1; /*!< SPI1 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE25 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE25 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE25 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE25 operator&(uint32_t value) const {
            ITLINE25 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE25 operator|(uint32_t value) const {
            ITLINE25 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE25, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE25, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE25, AccessType::ReadWrite>;
    };

    // interrupt line 26 status register
    union ITLINE26 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> SPI2; /*!< SPI2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE26 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE26 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE26 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE26 operator&(uint32_t value) const {
            ITLINE26 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE26 operator|(uint32_t value) const {
            ITLINE26 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE26, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE26, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE26, AccessType::ReadWrite>;
    };

    // interrupt line 27 status register
    union ITLINE27 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> USART1; /*!< USART1 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE27 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE27 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE27 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE27 operator&(uint32_t value) const {
            ITLINE27 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE27 operator|(uint32_t value) const {
            ITLINE27 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE27, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE27, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE27, AccessType::ReadWrite>;
    };

    // interrupt line 28 status register
    union ITLINE28 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> USART2; /*!< USART2 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE28 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE28 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE28 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE28 operator&(uint32_t value) const {
            ITLINE28 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE28 operator|(uint32_t value) const {
            ITLINE28 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE28, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE28, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE28, AccessType::ReadWrite>;
    };

    // interrupt line 29 status register
    union ITLINE29 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> USART3; /*!< USART3 */
            microhal::Bitfield<uint32_t, 1, 1> USART4; /*!< USART4 */
            microhal::Bitfield<uint32_t, 2, 1> USART5; /*!< USART5 */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE29 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE29 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE29 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE29 operator&(uint32_t value) const {
            ITLINE29 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE29 operator|(uint32_t value) const {
            ITLINE29 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE29, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE29, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE29, AccessType::ReadWrite>;
    };

    // interrupt line 30 status register
    union ITLINE30 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> USART2; /*!< CEC */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE30 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE30 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE30 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE30 operator&(uint32_t value) const {
            ITLINE30 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE30 operator|(uint32_t value) const {
            ITLINE30 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE30, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE30, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE30, AccessType::ReadWrite>;
    };

    // interrupt line 31 status register
    union ITLINE31 {
        union {
            microhal::Bitfield<uint32_t, 0, 1> RNG; /*!< RNG */
            microhal::Bitfield<uint32_t, 1, 1> AES; /*!< AES */
        };

        operator uint32_t() const { return raw; }
        operator bool() const { return raw; }

        ITLINE31 &operator=(uint32_t value) {
            raw = value;
            return *this;
        }
        ITLINE31 &operator|=(uint32_t value) {
            raw |= value;
            return *this;
        }
        ITLINE31 &operator&=(uint32_t value) {
            raw &= value;
            return *this;
        }

        bool operator==(uint32_t value) const { return raw == value; }
        bool operator!=(uint32_t value) const { return raw != value; }
        bool operator>(uint32_t value) const { return raw > value; }
        bool operator<(uint32_t value) const { return raw < value; }
        bool operator>=(uint32_t value) const { return raw >= value; }
        bool operator<=(uint32_t value) const { return raw <= value; }
        ITLINE31 operator&(uint32_t value) const {
            ITLINE31 tmp;
            tmp.raw = raw & value;
            return tmp;
        }
        ITLINE31 operator|(uint32_t value) const {
            ITLINE31 tmp;
            tmp.raw = raw | value;
            return tmp;
        }

     private:
        uint32_t raw;
        friend class VolatileRegister<ITLINE31, AccessType::ReadOnly>;
        friend class VolatileRegister<ITLINE31, AccessType::WriteOnly>;
        friend class VolatileRegister<ITLINE31, AccessType::ReadWrite>;
    };

    VolatileRegister<CFGR1, AccessType::ReadWrite> cfgr1;             /*!< SYSCFG configuration register 1	Address offset: 0x0 */
    uint32_t reserved1[5];                                            /*!< Reserved register	Address offset: 0x4 */
    VolatileRegister<CFGR2, AccessType::ReadWrite> cfgr2;             /*!< SYSCFG configuration register 1	Address offset: 0x18 */
    uint32_t reserved2[25];                                           /*!< Reserved register	Address offset: 0x1c */
    VolatileRegister<VREFBUF_CSR, AccessType::ReadWrite> vrefbuf_csr; /*!< VREFBUF control and status register	Address offset: 0x30 */
    VolatileRegister<VREFBUF_CCR, AccessType::ReadWrite> vrefbuf_ccr; /*!< VREFBUF calibration control register	Address offset: 0x34 */
    uint32_t reserved3[19];                                           /*!< Reserved register	Address offset: 0x38 */
    VolatileRegister<ITLINE0, AccessType::ReadWrite> itline0;         /*!< interrupt line 0 status register	Address offset: 0x80 */
    VolatileRegister<ITLINE1, AccessType::ReadWrite> itline1;         /*!< interrupt line 1 status register	Address offset: 0x84 */
    VolatileRegister<ITLINE2, AccessType::ReadWrite> itline2;         /*!< interrupt line 2 status register	Address offset: 0x88 */
    VolatileRegister<ITLINE3, AccessType::ReadWrite> itline3;         /*!< interrupt line 3 status register	Address offset: 0x8C */
    VolatileRegister<ITLINE4, AccessType::ReadWrite> itline4;         /*!< interrupt line 4 status register	Address offset: 0x90 */
    VolatileRegister<ITLINE5, AccessType::ReadWrite> itline5;         /*!< interrupt line 5 status register	Address offset: 0x94 */
    VolatileRegister<ITLINE6, AccessType::ReadWrite> itline6;         /*!< interrupt line 6 status register	Address offset: 0x98 */
    VolatileRegister<ITLINE7, AccessType::ReadWrite> itline7;         /*!< interrupt line 7 status register	Address offset: 0x9C */
    VolatileRegister<ITLINE8, AccessType::ReadWrite> itline8;         /*!< interrupt line 8 status register	Address offset: 0xA0 */
    VolatileRegister<ITLINE9, AccessType::ReadWrite> itline9;         /*!< interrupt line 9 status register	Address offset: 0xA4 */
    VolatileRegister<ITLINE10, AccessType::ReadWrite> itline10;       /*!< interrupt line 10 status register	Address offset: 0xA8 */
    VolatileRegister<ITLINE11, AccessType::ReadWrite> itline11;       /*!< interrupt line 11 status register	Address offset: 0xAC */
    VolatileRegister<ITLINE12, AccessType::ReadWrite> itline12;       /*!< interrupt line 12 status register	Address offset: 0xB0 */
    VolatileRegister<ITLINE13, AccessType::ReadWrite> itline13;       /*!< interrupt line 13 status register	Address offset: 0xB4 */
    VolatileRegister<ITLINE14, AccessType::ReadWrite> itline14;       /*!< interrupt line 14 status register	Address offset: 0xB8 */
    VolatileRegister<ITLINE15, AccessType::ReadWrite> itline15;       /*!< interrupt line 15 status register	Address offset: 0xBC */
    VolatileRegister<ITLINE16, AccessType::ReadWrite> itline16;       /*!< interrupt line 16 status register	Address offset: 0xC0 */
    VolatileRegister<ITLINE17, AccessType::ReadWrite> itline17;       /*!< interrupt line 17 status register	Address offset: 0xC4 */
    VolatileRegister<ITLINE18, AccessType::ReadWrite> itline18;       /*!< interrupt line 18 status register	Address offset: 0xC8 */
    VolatileRegister<ITLINE19, AccessType::ReadWrite> itline19;       /*!< interrupt line 19 status register	Address offset: 0xCC */
    VolatileRegister<ITLINE20, AccessType::ReadWrite> itline20;       /*!< interrupt line 20 status register	Address offset: 0xD0 */
    VolatileRegister<ITLINE21, AccessType::ReadWrite> itline21;       /*!< interrupt line 21 status register	Address offset: 0xD4 */
    VolatileRegister<ITLINE22, AccessType::ReadWrite> itline22;       /*!< interrupt line 22 status register	Address offset: 0xD8 */
    VolatileRegister<ITLINE23, AccessType::ReadWrite> itline23;       /*!< interrupt line 23 status register	Address offset: 0xDC */
    VolatileRegister<ITLINE24, AccessType::ReadWrite> itline24;       /*!< interrupt line 24 status register	Address offset: 0xE0 */
    VolatileRegister<ITLINE25, AccessType::ReadWrite> itline25;       /*!< interrupt line 25 status register	Address offset: 0xE4 */
    VolatileRegister<ITLINE26, AccessType::ReadWrite> itline26;       /*!< interrupt line 26 status register	Address offset: 0xE8 */
    VolatileRegister<ITLINE27, AccessType::ReadWrite> itline27;       /*!< interrupt line 27 status register	Address offset: 0xEC */
    VolatileRegister<ITLINE28, AccessType::ReadWrite> itline28;       /*!< interrupt line 28 status register	Address offset: 0xF0 */
    VolatileRegister<ITLINE29, AccessType::ReadWrite> itline29;       /*!< interrupt line 29 status register	Address offset: 0xF4 */
    VolatileRegister<ITLINE30, AccessType::ReadWrite> itline30;       /*!< interrupt line 30 status register	Address offset: 0xF8 */
    VolatileRegister<ITLINE31, AccessType::ReadWrite> itline31;       /*!< interrupt line 31 status register	Address offset: 0xFC */
};

#if defined(_MICROHAL_SYSCFG_VREFBUF_BASE_ADDRESS)
[[maybe_unused]] inline SYSCFG_VREFBUF *const syscfg = reinterpret_cast<SYSCFG_VREFBUF *>(_MICROHAL_SYSCFG_VREFBUF_BASE_ADDRESS);
#endif

}  // namespace registers
}  // namespace microhal
#endif  // _MICROHAL_PERIPHERAL_REGISTER_SYSCFG_VREFBUF
