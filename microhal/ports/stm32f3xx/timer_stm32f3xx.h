/*
 * timer_stm32f3xx.h
 *
 *  Created on: May 23, 2019
 *      Author: pokas
 */

#ifndef _MICROHAL_TIMER_STM32F3XX_H_
#define _MICROHAL_TIMER_STM32F3XX_H_

#include <cstdint>
#include "clockManager.h"
#include "device/stm32f3xx.h"
#include "gsl/span"
#include "signalSlot/signalSlot.h"

namespace microhal {
namespace stm32f3xx {

extern "C" {
void TIM3_IRQHandler(void);
}

template <typename type, int...>
class myBitfield;

template <typename type, int begin, int end>
class myBitfield<type, begin, end> {
 public:
    myBitfield &operator=(type value) {
        uint32_t tmp = data;
        tmp &= ~bitfieldMask;
        tmp |= (value & valueMask) << begin;
        data = tmp;
        return *this;
    }

    myBitfield &operator|=(type value) {
        uint32_t tmp = data;
        tmp |= (value & valueMask) << begin;
        data = tmp;
        return *this;
    }

    myBitfield &operator&=(type value) {
        uint32_t tmp = data;
        tmp &= (value | ~valueMask) << begin;
        data = tmp;
        return *this;
    }

    operator type() { return get(); }

    void set() { data |= bitfieldMask; }
    void clear() { data &= ~bitfieldMask; }
    type get() { return (data >> begin) & valueMask; }

 private:
    type data;

    static constexpr uint32_t maskGen(int maskBegin, int maskEnd) {
        uint32_t mask = 0;
        for (int i = maskBegin; i <= maskEnd; i++) {
            mask |= 1 << i;
        }
        return mask;
    }
    static_assert(maskGen(0, 0) == 0b01, "");
    static_assert(maskGen(0, 1) == 0b11, "");

    enum { bitfieldMask = maskGen(begin, end), valueMask = maskGen(0, end - begin) };
};

template <typename type, int begin, int end, int begin2, int end2>
class myBitfield<type, begin, end, begin2, end2> {
 public:
    myBitfield &operator=(type value) {
        uint32_t tmp = data;
        tmp &= ~(bitfieldMask1 | bitfieldMask2);
        tmp |= (value & valueMask1) << begin;
        tmp |= (value & valueMask2) << (begin2 - end);
        data = tmp;
        return *this;
    }

    myBitfield &operator|=(type value) {
        uint32_t tmp = data;
        tmp |= (value & valueMask1) << begin;
        tmp |= (value & valueMask2) << (begin2 - end);
        data = tmp;
        return *this;
    }

    myBitfield &operator&=(type value) {
        uint32_t tmp = data;
        tmp &= (value | ~valueMask1) << begin;
        tmp &= (value | ~valueMask2) << (begin2 - end);
        data = tmp;
        return *this;
    }

    operator type() { return get(); }

    void set() { data |= bitfieldMask1 | bitfieldMask2; }
    void clear() { data &= ~(bitfieldMask1 | bitfieldMask2); }
    type get() {
        type tmp = data;
        type value1 = (tmp & bitfieldMask1) >> begin;
        type value2 = (tmp & bitfieldMask2) >> (begin2 - end);
        return value1 | value2;
    }

 private:
    type data;

    static constexpr uint32_t maskGen(int maskBegin, int maskEnd) {
        uint32_t mask = 0;
        for (int i = maskBegin; i <= maskEnd; i++) {
            mask |= 1 << i;
        }
        return mask;
    }
    static_assert(maskGen(0, 0) == 0b01, "");
    static_assert(maskGen(0, 1) == 0b11, "");

    enum {
        bitfieldMask1 = maskGen(begin, end),
        valueMask1 = maskGen(0, end - begin),
        bitfieldMask2 = maskGen(begin2, end2),
        valueMask2 = maskGen(end - begin, end2 - begin2)
    };
};

struct TimerRegisterMap {
    union CR1_t {
        myBitfield<uint32_t, 0, 0> CEN;   // Counter enable
        myBitfield<uint32_t, 1, 1> UDIS;  // Update disable
        myBitfield<uint32_t, 2, 2> URS;   // Update request source
        myBitfield<uint32_t, 3, 3> OPM;   // One pulse mode
        myBitfield<uint32_t, 4, 4> DIR;   // Direction; 0 -> upcounter1, 1 -> downcounter
        myBitfield<uint32_t, 5, 6> CMS;   // Center-aligned mode selection
        myBitfield<uint32_t, 7, 7> ARPE;  // Auto-reload preload enable
        myBitfield<uint32_t, 8, 9> CKD;   // Clock division
        // bit 10 is reserved
        myBitfield<uint32_t, 11, 11> UIFREMAP;  // UIF status bit remapping

        uint32_t raw;
    };
    static_assert(sizeof(CR1_t) == sizeof(uint32_t), "Microhal internal error, probably incorrect toolchain configuration.");

    union CR2_t {
        myBitfield<uint32_t, 0, 0> CCPC;  // Capture/compare preload control
        // bit 1 is reserved, must be kept at reset value
        myBitfield<uint32_t, 2, 2> CCUS;  // Capture/compare control update selection
        myBitfield<uint32_t, 3, 3> CCDS;  // Capture/compare DMA selection
        myBitfield<uint32_t, 4, 6>
            MMS;                             /* Master mode selection
                                              * 000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO). If the reset is generated by the trigger
                                              *      input (slave mode controller configured in reset mode) then the signal on TRGO is delayed compared to the actual reset.
                                              * 001: Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO). It is useful to start several timers at the same
                                              *      time or to control a window in which a slave timer is enable. The Counter Enable signal is generated by a logic OR between
                                              *      CEN control bit and the trigger input when configured in gated mode. When the Counter Enable signal is controlled by the
                                              *      trigger input, there is a delay on TRGO, except if the master/slave mode is selected (see the MSM bit description in
                                              *      TIMx_SMCR register).
                                              * 010: Update - The update event is selected as trigger output (TRGO). For instance a master timer can then be used as a prescaler
                                              *      for a slave timer.
                                              * 011: Compare Pulse - The trigger output send a positive pulse when the CC1IF flag is to be set (even if it was already high), as
                                              *      soon as a capture or a compare match occurred. (TRGO).
                                              * 100: Compare - OC1REF signal is used as trigger output (TRGO)
                                              * 101: Compare - OC2REF signal is used as trigger output (TRGO)
                                              * 110: Compare - OC3REF signal is used as trigger output (TRGO)
                                              * 111: Compare - OC4REF signal is used as trigger output (TRGO)
                                              */
        myBitfield<uint32_t, 7, 7> TI1S;     // TI1 selection
        myBitfield<uint32_t, 8, 8> OIS1;     // Output Idle state 1 (OC1 output)
        myBitfield<uint32_t, 9, 9> OIS1N;    // Output Idle state 1 (OC1N output)
        myBitfield<uint32_t, 10, 10> OIS2;   // Output Idle state 2 (OC2 output)
        myBitfield<uint32_t, 11, 11> OIS2N;  // Output Idle state 2 (OC2N output)
        myBitfield<uint32_t, 12, 12> OIS3;   // Output Idle state 3 (OC3 output)
        myBitfield<uint32_t, 13, 13> OIS3N;  // Output Idle state 3 (OC3N output)
        myBitfield<uint32_t, 14, 14> OIS4;   // Output Idle state 4 (OC4 output)
        // bit 15 is reserved, must be kept at reset value.
        myBitfield<uint32_t, 16, 16> OIS5;  // Output Idle state 5 (OC5 output)
        // bit 17 Reserved, must be kept at reset value.
        myBitfield<uint32_t, 18, 18> OIS6;  // Output Idle state 6 (OC6 output)
        // bit 19 is reserved, must be kept at reset value.
        myBitfield<uint32_t, 20, 23>
            MMS2; /* Master mode selection 2
                   * These bits allow the information to be sent to ADC for synchronization (TRGO2) to be selected. The combination is as follows:
                   * 0000: Reset - the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger
                   *       input (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset.
                   * 0001: Enable - the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the
                   *       same time or to control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR
                   *       between the CEN control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is
                   *       controlled by the trigger input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit
                   *       description in TIMx_SMCR register).
                   * 0010: Update - the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a
                   *       prescaler for a slave timer.
                   * 0011: Compare pulse - the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high),
                   *       as soon as a capture or compare match occurs (TRGO2).
                   * 0100: Compare - OC1REF signal is used as trigger output (TRGO2)
                   * 0101: Compare - OC2REF signal is used as trigger output (TRGO2)
                   * 0110: Compare - OC3REF signal is used as trigger output (TRGO2)
                   * 0111: Compare - OC4REF signal is used as trigger output (TRGO2)
                   * 1000: Compare - OC5REF signal is used as trigger output (TRGO2)
                   * 1001: Compare - OC6REF signal is used as trigger output (TRGO2)
                   * 1010: Compare Pulse - OC4REF rising or falling edges generate pulses on TRGO2
                   * 1011: Compare Pulse - OC6REF rising or falling edges generate pulses on TRGO2
                   * 1100: Compare Pulse - OC4REF or OC6REF rising edges generate pulses on TRGO2
                   * 1101: Compare Pulse - OC4REF rising or OC6REF falling edges generate pulses on TRGO2
                   * 1110: Compare Pulse - OC5REF or OC6REF rising edges generate pulses on TRGO2
                   * 1111: Compare Pulse - OC5REF rising or OC6REF falling edges generate pulses on TRGO2
                   **/

        uint32_t raw;
    };

    union SMCR_t {
        // myBitfield<uint32_t, 0, 2> SMSa;    // Slave mode selection
        myBitfield<uint32_t, 3, 3> OCCS;    // OCREF clear selection
        myBitfield<uint32_t, 4, 6> TS;      //  Trigger selection
        myBitfield<uint32_t, 7, 7> MSM;     // Master/slave mode
        myBitfield<uint32_t, 8, 11> ETF;    // External trigger filter
        myBitfield<uint32_t, 12, 13> ETPS;  // External trigger prescaler
        myBitfield<uint32_t, 14, 14> ECE;   // External clock enable
        myBitfield<uint32_t, 15, 15> ETP;   // External trigger polarity
        // myBitfield<uint32_t, 16, 16> SMSb ;  // Slave mode selection

        uint32_t raw;

        void setSMS(uint32_t sms) {
            uint32_t tmp = raw;
            tmp &= ~0x0001'0007;
            tmp |= (sms & 0b111) | ((sms & 0b1000) << 13);
            raw = tmp;
        }

        uint32_t getSMS() {
            uint32_t tmp = raw;
            uint32_t sms = tmp & 0b111;
            sms |= (tmp >> 13) & 0b1000;
            return sms;
        }
    };

    union CCMR1_t {
        union BitfieldInput {
            myBitfield<uint32_t, 0, 1> CC1S;      /* Capture/Compare 1 Selection
                                                   * 00: Forbidden in input capture mode
                                                   * 01: CC1 channel is configured as input, IC1 is mapped on TI1
                                                   * 10: CC1 channel is configured as input, IC1 is mapped on TI2
                                                   * 11: CC1 channel is configured as input, IC1 is mapped on TRC.
                                                   *     This mode is working only if an internal trigger input
                                                   *     is selected through TS bit (TIMx_SMCR register)
                                                   */
            myBitfield<uint32_t, 2, 3> IC1PSC;    // Input capture 1 prescaler
            myBitfield<uint32_t, 4, 7> IC1F;      // Input capture 1 filte
            myBitfield<uint32_t, 8, 9> CC2S;      // Capture/Compare 2 selection
            myBitfield<uint32_t, 10, 11> IC2PSC;  // Input capture 2 prescaler
            myBitfield<uint32_t, 12, 15> IC2F;    // Input capture 2 filter
        };
        union BitfieldOutput {
            myBitfield<uint32_t, 0, 1> CC1S;  /* Capture/Compare 1 Selection
                                               * 00: CC1 channel is configured as output
                                               * 01: Forbidden in output compare mode
                                               * 10: Forbidden in output compare mode
                                               * 11: Forbidden in output compare mode
                                               */
            myBitfield<uint32_t, 2, 2> OC1FE; /* Output Compare 1 fast enable
                                               * 0: CC1 behaves normally depending on counter and CCR1 values even
                                               *    when the trigger is ON. The minimum delay to activate CC1 output
                                               *    when an edge occurs on the trigger input is 5 clock cycles.
                                               * 1: An active edge on the trigger input acts like a compare match
                                               *    on CC1 output. Then, OC is set to the compare level independently
                                               *    from the result of the comparison. Delay to sample the trigger
                                               *    input and to activate CC1 output is reduced to 3 clock cycles.
                                               *    OCFE acts only if the channel is configured in PWM1 or PWM2 mode.
                                               */
            myBitfield<uint32_t, 3, 3> OC1PE; /* Output Compare 1 preload enable
                                               * 0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written
                                               *    at anytime, the new value is taken in account immediately.
                                               * 1: Preload register on TIMx_CCR1 enabled. Read/Write operations
                                               *    access the preload register. TIMx_CCR1 preload value is loaded
                                               *    in the active register at each update event.
                                               */
            myBitfield<uint32_t, 4, 6, 16, 16> OC1M;
            myBitfield<uint32_t, 4, 6> OC1Ma;           /* Output Compare 1 mode
                                                         * 0000: Frozen - The comparison between the output compare register
                                                         *       TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.
                                                         * 0001: Set channel 1 to active level on match. OC1REF signal is forced
                                                         *       high when the counter TIMx_CNT matches the capture/compare register
                                                         * 0010: Set channel 1 to inactive level on match. OC1REF signal is forced
                                                         *       low when the counter TIMx_CNT matches the capture/compare register
                                                         * 0011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
                                                         * 0100: Force inactive level - OC1REF is forced low.
                                                         * 0101: Force active level - OC1REF is forced high.
                                                         * 0110: PWM mode 1
                                                         * 0111: PWM mode 2
                                                         * 1000: Retrigerrable OPM mode 1
                                                         * 1001: Retrigerrable OPM mode 2
                                                         * 1010: Reserved
                                                         * 1011: Reserved
                                                         * 1100: Combined PWM mode 1
                                                         * 1101: Combined PWM mode 2
                                                         * 1110: Asymmetric PWM mode 1
                                                         * 1111: Asymmetric PWM mode 2
                                                         */
            myBitfield<uint32_t, 7, 7> OC1CE;           // Output Compare 1 clear enable
            myBitfield<uint32_t, 8, 9> CC2S;            // Capture/Compare 2 selection
            myBitfield<uint32_t, 10, 10> OC2FE;         // Output Compare 2 fast enable, Look at CC1S
            myBitfield<uint32_t, 11, 11> OC2PE;         // Output Compare 2 preload enable, Look at CC1S
            myBitfield<uint32_t, 12, 14, 24, 24> OC2M;  // Output Compare 2 mode
            myBitfield<uint32_t, 12, 14> OC2Ma;         // Output Compare 2 mode
            myBitfield<uint32_t, 15, 15> OC2CE;         // Output Compare 2 clear enable, Look at CC1S
            myBitfield<uint32_t, 16, 16> OC1Mb;         // Output Compare 1 mode - bit 3
                                                        // bits 17 - 23 are reserved, must be kept at reset value.
            myBitfield<uint32_t, 24, 24> OC2Mb;         // Output Compare 2 mode - bit 3
        };

        void setOC1M(uint32_t value) {
            uint32_t tmp = raw;
            tmp &= ~0x0001'0070;
            tmp |= (value & 0b0111) << 4;
            tmp |= (value & 0b1000) << 13;
            raw = tmp;
        }
        void setOC2M(uint32_t value) {
            uint32_t tmp = raw;
            tmp &= ~0x0100'7000;
            tmp |= (value & 0b0111) << 12;
            tmp |= (value & 0b1000) << 21;
            raw = tmp;
        }
        BitfieldInput bitfieldInput;
        BitfieldOutput bitfieldOutput;
        uint32_t raw;
    };

    union CCMR2_t {
        union BitfieldInput {
            myBitfield<uint32_t, 0, 1> CC3S;      // Capture/Compare 3 Selection
            myBitfield<uint32_t, 2, 3> IC3PSC;    // Input capture 3 prescaler
            myBitfield<uint32_t, 4, 7> IC3F;      // Input capture 3 filte
            myBitfield<uint32_t, 8, 9> CC4S;      // Capture/Compare 4 selection
            myBitfield<uint32_t, 10, 11> IC4PSC;  // Input capture 4 prescaler
            myBitfield<uint32_t, 12, 15> IC4F;    // Input capture 4 filter
        };
        union BitfieldOutput {
            myBitfield<uint32_t, 0, 1> CC3S;     // Capture/Compare 1 Selection, for more information loock at CCMR1_t
            myBitfield<uint32_t, 2, 2> OC3FE;    // Output Compare 1 fast enable, for more information loock at CCMR1_t
            myBitfield<uint32_t, 3, 3> OC3PE;    // Output Compare 1 preload enable, for more information loock at CCMR1_t
            myBitfield<uint32_t, 4, 6> OC3Ma;    // Output Compare 1 mode, for more information loock at CCMR1_t
            myBitfield<uint32_t, 7, 7> OC3CE;    // Output Compare 1 clear enable, for more information loock at CCMR1_t
            myBitfield<uint32_t, 8, 9> CC4S;     // Capture/Compare 2 selection, for more information loock at CCMR1_t
            myBitfield<uint32_t, 10, 10> OC4FE;  // Output Compare 2 fast enable, for more information loock at CCMR1_t
            myBitfield<uint32_t, 11, 11> OC4PE;  // Output Compare 2 preload enable, for more information loock at CCMR1_t
            myBitfield<uint32_t, 12, 14> OC4Ma;  // Output Compare 2 mode, for more information loock at CCMR1_t
            myBitfield<uint32_t, 15, 15> OC4CE;  // Output Compare 2 clear enable, for more information loock at CCMR1_t
            myBitfield<uint32_t, 16, 16> OC3Mb;  // Output Compare 1 mode - bit 3, for more information loock at CCMR1_t
                                                 // bits 17 - 23 are reserved, must be kept at reset value.
            myBitfield<uint32_t, 24, 24> OC4Mb;  // Output Compare 2 mode - bit 3, for more information loock at CCMR1_t
        };
        void setOC3M(uint32_t value) {
            uint32_t tmp = raw;
            tmp &= ~0x0001'0070;
            tmp |= (value & 0b0111) << 4;
            tmp |= (value & 0b1000) << 13;
            raw = tmp;
        }
        void setOC4M(uint32_t value) {
            uint32_t tmp = raw;
            tmp &= ~0x0100'7000;
            tmp |= (value & 0b0111) << 12;
            tmp |= (value & 0b1000) << 21;
            raw = tmp;
        }

        BitfieldInput bitfieldInput;
        BitfieldOutput bitfieldOutput;
        uint32_t raw;
    };
    union CCER_t {
        myBitfield<uint32_t, 0, 0> CC1E;     /* Capture/Compare 1 output enable
                                              * CC1 channel configured as output:
                                              * 0: Off - OC1 is not active. OC1 level is then function
                                              *    of MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
                                              * 1: On - OC1 signal is output on the corresponding output pin
                                              *    depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
                                              */
        myBitfield<uint32_t, 1, 1> CC1P;     /* Capture/Compare 1 output polarity;
                                              * CC1 channel configured as output:
                                              * 0: OC1 active high
                                              * 1: OC1 active low
                                              */
        myBitfield<uint32_t, 2, 2> CC1NE;    /* Capture/Compare 1 complementary output enable
                                              * 0: Off - OC1N is not active. OC1N level is then function
                                              *    of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
                                              * 1: On - OC1N signal is output on the corresponding output pin
                                              *    depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
                                              */
        myBitfield<uint32_t, 3, 3> CC1NP;    /* Capture/Compare 1 complementary output polarity
                                              * CC1 channel configured as output:
                                              * 0: OC1N active high.
                                              * 1: OC1N active low.
                                              */
        myBitfield<uint32_t, 4, 4> CC2E;     // Capture/Compare 2 output enableRefer to CC1E description
        myBitfield<uint32_t, 5, 5> CC2P;     // Capture/Compare 2 output polarityRefer to CC1P description
        myBitfield<uint32_t, 6, 6> CC2NE;    // Capture/Compare 2 complementary output enableRefer to CC1NE description
        myBitfield<uint32_t, 7, 7> CC2NP;    // Capture/Compare 2 complementary output polarityRefer to CC1NP description
        myBitfield<uint32_t, 8, 8> CC3E;     // Capture/Compare 3 output enableRefer to CC1E description
        myBitfield<uint32_t, 9, 9> CC3P;     // Capture/Compare 3 output polarityRefer to CC1P description
        myBitfield<uint32_t, 10, 10> CC3NE;  // Capture/Compare 3 complementary output enableRefer to CC1NE description
        myBitfield<uint32_t, 11, 11> CC3NP;  // Capture/Compare 3 complementary output polarityRefer to CC1NP description
        myBitfield<uint32_t, 12, 12> CC4E;   // Capture/Compare 4 output enableRefer to CC1E description
        myBitfield<uint32_t, 13, 13> CC4P;   // Capture/Compare 4 output polarityRefer to CC1P description
        // bit 14 reserved
        myBitfield<uint32_t, 15, 15> CC4NP;  // Capture/Compare 4 complementary output polarityRefer to CC1NP description
        myBitfield<uint32_t, 16, 16> CC5E;   // Capture/Compare 5 output enableRefer to CC1E description
        myBitfield<uint32_t, 17, 17> CC5P;   // Capture/Compare 5 output polarityRefer to CC1P description
        // bits 18-19 are reserved, must be kept at reset value.
        myBitfield<uint32_t, 20, 20> CC6E;  // Capture/Compare 6 output enableRefer to CC1E description
        myBitfield<uint32_t, 3, 3> CC6P;    // Capture/Compare 6 output polarityRefer to CC1P description
        // bits 22 - 31 reserved

        uint32_t raw;
    };

    union BDTR_t {
        myBitfield<uint32_t, 0, 7> DTG;
        myBitfield<uint32_t, 8, 9> LOCK;
        myBitfield<uint32_t, 10, 10> OSSI;
        myBitfield<uint32_t, 11, 11> OSSR;
        myBitfield<uint32_t, 12, 12> BKE;
        myBitfield<uint32_t, 13, 13> BKP;
        myBitfield<uint32_t, 14, 14> AOE;
        myBitfield<uint32_t, 15, 15> MOE;
        myBitfield<uint32_t, 16, 19> BKF;
        myBitfield<uint32_t, 20, 23> BK2F;
        myBitfield<uint32_t, 24, 24> BK2E;
        myBitfield<uint32_t, 25, 25> BK2P;

        uint32_t raw;
    };

    CR1_t CR1;
    CR2_t CR2;
    SMCR_t SMCR;
    uint32_t DIER;
    uint32_t SR;
    uint32_t EGR;    // event generation register
    CCMR1_t CCMR1;   // capture/compare mode register 1
    CCMR2_t CCMR2;   // capture/compare mode register 2
    CCER_t CCER;     // capture/compare enable register
    uint32_t CNT;    // counter
    uint32_t PSC;    // prescaler
    uint32_t ARR;    // auto-reload register
    uint32_t RCR;    // repetition counter register
    uint32_t CCR1;   // capture/compare register 1
    uint32_t CCR2;   // capture/compare register 2
    uint32_t CCR3;   // capture/compare register 3
    uint32_t CCR4;   // capture/compare register 4
    BDTR_t BDTR;     // break and dead-time register
    uint32_t DCR;    // DMA control register
    uint32_t DMAR;   // DMA address for full transfer
    uint32_t OR;     // option registers
    uint32_t CCMR3;  // capture/compare mode register 3
    uint32_t CCR5;   // capture/compare register 5
    uint32_t CCR6;   // capture/compare register 6
};                   // namespace stm32f3xx

namespace timer_detail {
enum class Interrupt {
    Update = 0b0001,
    CaptureCompare1 = 0b0010,
    CaptureCompare2 = 0b0100,
    CaptureCompare3 = 0b1000,
    CaptureCompare4 = 0b0001'0000,
    COM = 0b0010'0000,
    Trigger = 0b0100'0000,
    Break = 0b1000'0000
};

enum class Event {
    Update = 0b0001,
    CaptureCompare1 = 0b0010,
    CaptureCompare2 = 0b0100,
    CaptureCompare3 = 0b1000,
    CaptureCompare4 = 0b0001'0000,
    COM = 0b0010'0000,
    Trigger = 0b0100'0000,
    Break = 0b1000'0000,
    Break2 = 0b0001'0000'0000
};

constexpr Interrupt operator&(Interrupt a, Interrupt b) {
    return static_cast<Interrupt>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));
}

constexpr uint32_t operator&(uint32_t a, Interrupt b) {
    return a & static_cast<uint32_t>(b);
}
}  // namespace timer_detail

using timer_detail::operator&;

class Timer {
 public:
    using Interrupt = timer_detail::Interrupt;
    using Event = timer_detail::Event;
    enum class Mode {
        EdgeAligned,    ///<! The counter counts up or down depending on the direction set by function @ref setDirection
        CenterAligned1, /** The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00
                         *  in TIMx_CCMRx register) are set only when the counter is counting down.
                         */
        CenterAligned2, /** The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in
                         *  TIMx_CCMRx register) are set only when the counter is counting up.
                         */
        CenterAligned3  /** The counter counts up and down alternatively. Output compare interrupt flags of channels configured in output (CCxS=00 in
                         *  TIMx_CCMRx register) are set both when the counter is counting up or down.
                         */
    };
    enum class Direction { UpCounter = 0x0, DownCounter = 0x1 };
    enum class ClockSource { Internal, ETRPin };
    enum class CommutationEventSource { COMEventOnly, COMEventOrTrigger };
    enum class Trigger {
        InternalTrigger0 = 0b000,
        InternalTrigger1,
        InternalTrigger2,
        InternalTrigger3,
        TI1EdgeDetector,
        FilteredTimerInput1,
        FilteredTimerInput2,
        ExternalTriggerInput
    };
    enum class MasterMode { Reset = 0b000, Enable, Update, ComparePulse, Compare1, Compare2, Compare3, Compare4 };
    enum class ADCSynchronizationEvent {
        Reset = 0b000, /* the UG bit from the TIMx_EGR register is used as trigger output (TRGO2). If the reset is generated by the trigger input
                        * (slave mode controller configured in reset mode), the signal on TRGO2 is delayed compared to the actual reset.
                        */
        Enable, /* the Counter Enable signal CNT_EN is used as trigger output (TRGO2). It is useful to start several timers at the same time or to
                 * control a window in which a slave timer is enabled. The Counter Enable signal is generated by a logic OR between the CEN
                 *control bit and the trigger input when configured in Gated mode. When the Counter Enable signal is controlled by the trigger
                 *input, there is a delay on TRGO2, except if the Master/Slave mode is selected (see the MSM bit description in TIMx_SMCR
                 *register).
                 **/
        Update, /* the update event is selected as trigger output (TRGO2). For instance, a master timer can then be used as a prescaler for a
                 * slave timer.
                 */
        ComparePulse,   /* the trigger output sends a positive pulse when the CC1IF flag is to be set (even if it was already high), as soon as a
                         * capture or compare match occurs (TRGO2).
                         */
        Compare1,       // OC1REF signal is used as trigger output (TRGO2)
        Compare2,       // OC2REF signal is used as trigger output (TRGO2)
        Compare3,       // OC3REF signal is used as trigger output (TRGO2)
        Compare4,       // OC4REF signal is used as trigger output (TRGO2)
        Compare5,       // OC5REF signal is used as trigger output (TRGO2)
        Compare6,       // OC6REF signal is used as trigger output (TRGO2)
        Compare4Pulse,  // OC4REF rising or falling edges generate pulses on TRGO2
        Compare6Pulse,  // OC6REF rising or falling edges generate pulses on TRGO2
        Compare4Or6RisingEdge,         // OC4REF or OC6REF rising edges generate pulses on TRGO2
        Compare4RisingOr6FallingEdge,  // OC4REF rising or OC6REF falling edges generate pulses on TRGO2
        Compare5Or6RisinggEdge,        // OC5REF or OC6REF rising edges generate pulses on TRGO2
        Compare5RisingOr6FallingEdge,  // OC5REF rising or OC6REF falling edges generate pulses on TRGO2
    };
    enum class SlaveMode {
        Disabled = 0b000,
        EncoderMode1,
        EncoderMode2,
        EncoderMode3,
        ResetMode,
        GatedMode,
        TriggerMode,
        ExternalClockMode1,
        CombinedResetAndTrigger
    };

    Timer(void *addr)
        : timer(*static_cast<TimerRegisterMap *>(addr)),
          compare1(*static_cast<TimerRegisterMap *>(addr), 1),
          compare2(*static_cast<TimerRegisterMap *>(addr), 2),
          compare3(*static_cast<TimerRegisterMap *>(addr), 3),
          compare4(*static_cast<TimerRegisterMap *>(addr), 4),
          capture1(*static_cast<TimerRegisterMap *>(addr), 1) {
        if (addr == TIM3) {
            tim3 = this;
        }
        ClockManager::enable(*static_cast<TIM_TypeDef *>(addr));
    }
    ~Timer() {
        disableInterrupt();
        if ((TIM_TypeDef *)&timer == TIM3) {
            tim3 = nullptr;
        }
    }

    /**
     * @brief This function enable timer.
     */
    void enable() { timer.CR1.CEN = 1; }
    /**
     * @brief This function disable timer.
     */
    void disable() { timer.CR1.CEN = 0; }

    void enableInterupt(uint32_t priority) {
        IRQn_Type irq = getIRQn();
        NVIC_SetPriority(irq, priority);
        NVIC_ClearPendingIRQ(irq);
        NVIC_EnableIRQ(irq);
    }

    void disableInterrupt() { NVIC_EnableIRQ(getIRQn()); }

    void enableInterrupts(Interrupt interrupt) { timer.DIER |= static_cast<uint32_t>(interrupt); }

    void setMode(Mode mode) { timer.CR1.CMS = static_cast<uint32_t>(mode); }

    /**
     * @brief This function set timer direction.
     *
     * @param direction - new timer direction.
     */
    void setDirection(Direction direction) { timer.CR1.DIR = static_cast<uint32_t>(direction); }
    /**
     * This function return current direction setting
     * @return Direction
     */
    Direction getDirection() { return static_cast<Direction>(timer.CR1.DIR.get()); }

    void enableAutoReload() { timer.CR1.ARPE = 1; }
    void disableAutoReload() { timer.CR1.ARPE = 0; }

    void setAutoReloadRegister(uint32_t value) { timer.ARR = value; }
    uint32_t getAutoReloadRegiser() const { return timer.ARR; }

    void disableUpdateEventGeneration() { timer.CR1.UDIS = 1; }

    void setPrescaler(uint16_t prescaler) { timer.PSC = prescaler; }
    uint32_t getPrescaler() const { return timer.PSC; }

    void setClockSource(ClockSource clockSource) {
        switch (clockSource) {
            case ClockSource::Internal:
                break;
            case ClockSource::ETRPin:
                timer.SMCR.ETF = 0;
                timer.SMCR.ETPS = 0;
                timer.SMCR.ETP = 0;
                timer.SMCR.ECE = 1;
                break;
        }
    }

    void enableCaptureComparePreaload(CommutationEventSource commutationEventSource) {
        timer.CR2.CCUS = static_cast<uint32_t>(commutationEventSource);
        timer.CR2.CCPC = 1;
    }

    void disableCaptureComparePreaload() { timer.CR2.CCPC = 0; }

    bool registerIsrFunction(void (*interruptFunction)(void)) {
        if (signal.connect(interruptFunction)) {
            return true;
        }
        return false;
    }

    uint32_t maxCounterValue() const { return 0xFFFF; }

    uint32_t getTimerClockSourceFrequency() const { return ClockManager::TimerFrequency(*(TIM_TypeDef *)&timer); }
    uint32_t getTimerCounterFrequency() const { return ClockManager::TimerFrequency(*(TIM_TypeDef *)&timer) / getPrescaler(); }
    // one tick duration in [ns]
    uint32_t getTickPeriod() const {
        uint32_t timerFrequency = ClockManager::TimerFrequency(*(TIM_TypeDef *)&timer);
        return (uint64_t{1000'000'000} * getPrescaler()) / timerFrequency;
    }

    void configureADCSyncronizationSource(ADCSynchronizationEvent adcSync) { timer.CR2.MMS2 = static_cast<uint32_t>(adcSync); }

    class OutputCompare {
     public:
        enum class Mode {
            Frozen = 0,  //! The comparison between the output compare register TIMx_CCRx and the counter TIMx_CNT has no effect on the outputs.(this
                         //! mode is used to generate a timing base).
            SetChannelToActiveOnMatch,    //! Set channel x to active level on match. OCxREF signal is forced high when the counter TIMx_CNT matches
                                          //! the capture/compare register
            SetChannelToInactiveOnMatch,  //! Set channel x to inactive level on match. OC1REF signal is forced low when the counter TIMx_CNT matches
                                          //! the capture/compare register x (TIMx_CCRx).
            Toggle,                       //! OCxREF toggles when TIMx_CNT=TIMx_CCRx
            ForceInactiveLevel,           //! OCxREF is forced low.
            ForceActiveLevel,             //! OCxREF is forced high.
            PWMMode1,  //! In upcounting, channel x is active as long as TIMx_CNT<TIMx_CCRx else inactive. In downcounting, channel x is inactive
                       //! (OCxREF=‘0’) as long as TIMx_CNT>TIMx_CCR1 else active (OCxREF=’1’).
            PWMMode2,  //! In upcounting, channel 1 is inactive as long as TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active as
                       //! long as TIMx_CNT>TIMx_CCR1 else inactive
            OnePulseMode1,
            OnePulseMode2,
            CombinedPWMMode1 = 0b1100,  //! OC1REF has the same behavior as in PWM mode 1. OC1REFC is the logical OR between OC1REF and OC2REF.
            CombinedPWMMode2,           //! OC1REF has the same behavior as in PWM mode 2. OC1REFC is the logical AND between OC1REF and OC2REF.
            AssymmetricPWMMode1,  //! OC1REF has the same behavior as in PWM mode 1. OC1REFC outputs OC1REF when the counter is counting up, OC2REF
                                  //! when it is counting down.
            AssymmetricPWMMode2   //! OC1REF has the same behavior as in PWM mode 2. OC1REFC outputs OC1REF when the counter is counting up, OC2REF
                                  //! when it is counting down.
        };

        enum class Polarity { ActiveHigh = 0, ActiveLow };
        enum class IdleState { Low, High };

        void enable() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCMR1.bitfieldOutput.CC1S = 0;
                    break;
                case 2:
                    timer.CCMR1.bitfieldOutput.CC2S = 0;
                    break;
                case 3:
                    timer.CCMR2.bitfieldOutput.CC3S = 0;
                    break;
                case 4:
                    timer.CCMR2.bitfieldOutput.CC4S = 0;
                    break;
            }
        }

        void setValue(uint32_t value) {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCR1 = value;
                    break;
                case 2:
                    timer.CCR2 = value;
                    break;
                case 3:
                    timer.CCR3 = value;
                    break;
                case 4:
                    timer.CCR4 = value;
                    break;
            }
        }
        uint32_t getValue() {
            switch (compareChannelNumber) {
                case 1:
                    return timer.CCR1;
                case 2:
                    return timer.CCR2;
                case 3:
                    return timer.CCR3;
                case 4:
                    return timer.CCR4;
            }
        }
        void enablePreload() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCMR1.bitfieldOutput.OC1PE = 1;
                    break;
                case 2:
                    timer.CCMR1.bitfieldOutput.OC2PE = 1;
                    break;
                case 3:
                    timer.CCMR2.bitfieldOutput.OC3PE = 1;
                    break;
                case 4:
                    timer.CCMR2.bitfieldOutput.OC4PE = 1;
                    break;
            }
        }
        void disablePreload() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCMR1.bitfieldOutput.OC1PE = 0;
                    break;
                case 2:
                    timer.CCMR1.bitfieldOutput.OC2PE = 0;
                    break;
                case 3:
                    timer.CCMR2.bitfieldOutput.OC3PE = 0;
                    break;
                case 4:
                    timer.CCMR2.bitfieldOutput.OC4PE = 0;
                    break;
            }
        }
        void setMode(Mode mode) {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCMR1.bitfieldOutput.OC1M = static_cast<uint32_t>(mode);
                    break;
                case 2:
                    timer.CCMR1.bitfieldOutput.OC2M = static_cast<uint32_t>(mode);
                    break;
                case 3:
                    timer.CCMR2.setOC3M(static_cast<uint32_t>(mode));
                    break;
                case 4:
                    timer.CCMR2.setOC4M(static_cast<uint32_t>(mode));
                    break;
            }
        }
        void configureOutput(Polarity polarity, IdleState idleState) {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCER.CC1P = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS1 = static_cast<uint32_t>(idleState);
                    break;
                case 2:
                    timer.CCER.CC2P = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS2 = static_cast<uint32_t>(idleState);
                    break;
                case 3:
                    timer.CCER.CC3P = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS3 = static_cast<uint32_t>(idleState);
                    break;
                case 4:
                    timer.CCER.CC4P = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS4 = static_cast<uint32_t>(idleState);
                    break;
            }
        }
        /**
         * Note: idleState is by default disabled. To enable idleState functionality call TODO function.
         * @param polarity
         * @param idleState
         */
        void configureComplementaryOutput(Polarity polarity, IdleState idleState) {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCER.CC1NP = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS1N = static_cast<uint32_t>(idleState);
                    break;
                case 2:
                    timer.CCER.CC2NP = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS2N = static_cast<uint32_t>(idleState);
                    break;
                case 3:
                    timer.CCER.CC3NP = static_cast<uint32_t>(polarity);
                    timer.CR2.OIS3N = static_cast<uint32_t>(idleState);
                    break;
            }
        }

        void outputEnable() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCER.CC1E = 1;
                    break;
                case 2:
                    timer.CCER.CC2E = 1;
                    break;
                case 3:
                    timer.CCER.CC3E = 1;
                    break;
                case 4:
                    timer.CCER.CC4E = 1;
                    break;
            }
        }

        void complementaryOutputEnable() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCER.CC1NE = 1;
                    break;
                case 2:
                    timer.CCER.CC2NE = 1;
                    break;
                case 3:
                    timer.CCER.CC3NE = 1;
                    break;
            }
        }

        void outputDisable() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCER.CC1E = 0;
                    break;
                case 2:
                    timer.CCER.CC2E = 0;
                    break;
                case 3:
                    timer.CCER.CC3E = 0;
                    break;
                case 4:
                    timer.CCER.CC4E = 0;
                    break;
            }
        }
        void complementaryOutputDisable() {
            switch (compareChannelNumber) {
                case 1:
                    timer.CCER.CC1NE = 0;
                    break;
                case 2:
                    timer.CCER.CC2NE = 0;
                    break;
                case 3:
                    timer.CCER.CC3NE = 0;
                    break;
            }
        }

     private:
        TimerRegisterMap &timer;
        uint_fast8_t compareChannelNumber;

        OutputCompare(TimerRegisterMap &timer, uint_fast8_t channel) : timer(timer), compareChannelNumber(channel) {}
        friend Timer;
    };

    class InputCapture {
     public:
        enum class InputSource { TRC = 0b11, TI1 = 0b01, TI2 = 0b10, TI3 = 0b101, TI4 = 0b110 };
        enum class InputPrescaler { None = 0, Prescaler2, Prescaler4, Prescaler8 };
        enum class ActiveEdge { Rising = 0b00, Falling = 0b01, RisingAndFalling = 0b11 };

        void enable() {
            switch (captureChannelNumber) {
                case 1:
                    timer.CCER.CC1E = 1;
                    break;
                case 2:
                    timer.CCER.CC2E = 1;
                    break;
                case 3:
                    timer.CCER.CC3E = 1;
                    break;
                case 4:
                    timer.CCER.CC4E = 1;
                    break;
            }
        }

        void disable() {
            switch (captureChannelNumber) {
                case 1:
                    timer.CCER.CC1E = 0;
                    break;
                case 2:
                    timer.CCER.CC2E = 0;
                    break;
                case 3:
                    timer.CCER.CC3E = 0;
                    break;
                case 4:
                    timer.CCER.CC4E = 0;
                    break;
            }
        }

        bool setInputSource(InputSource inputSource, ActiveEdge activeEdge) {
            switch (captureChannelNumber) {
                case 1:
                    if (static_cast<uint32_t>(inputSource) & 0b100) return false;  // Selected TI3 or TI4 witch is forbidden on this channel
                    timer.CCMR1.bitfieldInput.CC1S = static_cast<uint32_t>(inputSource);
                    timer.CCER.CC1P = static_cast<uint32_t>(activeEdge);
                    return true;
                case 2:
                    if (static_cast<uint32_t>(inputSource) & 0b100) return false;  // Selected TI3 or TI4 witch is forbidden on this channel
                    static constexpr const uint8_t map[4] = {0b00, 0b10, 0b01, 0b11};
                    timer.CCMR1.bitfieldInput.CC2S = map[static_cast<uint32_t>(inputSource)];
                    timer.CCER.CC2P = static_cast<uint32_t>(activeEdge);
                    return true;
                case 3:
                    if (!(static_cast<uint32_t>(inputSource) & 0b100)) return false;  // Selected TI3 or TI4 witch is forbidden on this channel
                    timer.CCMR2.bitfieldInput.CC3S =
                        static_cast<uint32_t>(inputSource);  // no need to mask MSB bit, it will be truncated during field assignment
                    timer.CCER.CC3P = static_cast<uint32_t>(activeEdge);
                    return true;
                case 4:
                    if (!(static_cast<uint32_t>(inputSource) & 0b100)) return false;  // Selected TI3 or TI4 witch is forbidden on this channel
                    static constexpr const uint8_t map2[4] = {0b00, 0b10, 0b01, 0b11};
                    timer.CCMR2.bitfieldInput.CC4S = map2[static_cast<uint32_t>(inputSource) & 0b11];
                    timer.CCER.CC4P = static_cast<uint32_t>(activeEdge);
                    return true;
            }
        }

        void setInputPrescaler(InputPrescaler inputPrescaler) {
            switch (captureChannelNumber) {
                case 1:
                    timer.CCMR1.bitfieldInput.IC1PSC = static_cast<uint32_t>(inputPrescaler);
                    break;
                case 2:
                    timer.CCMR1.bitfieldInput.IC2PSC = static_cast<uint32_t>(inputPrescaler);
                    break;
                case 3:
                    timer.CCMR2.bitfieldInput.IC3PSC = static_cast<uint32_t>(inputPrescaler);
                    break;
                case 4:
                    timer.CCMR2.bitfieldInput.IC4PSC = static_cast<uint32_t>(inputPrescaler);
                    break;
            }
        }

        uint32_t getValue() {
            switch (captureChannelNumber) {
                case 1:
                    return timer.CCR1;
                case 2:
                    return timer.CCR2;
                case 3:
                    return timer.CCR3;
                case 4:
                    return timer.CCR4;
            }
            std::terminate();
        }

     private:
        TimerRegisterMap &timer;
        uint_fast8_t captureChannelNumber;

        InputCapture(TimerRegisterMap &timer, uint_fast8_t channel) : timer(timer), captureChannelNumber(channel) {}
        friend Timer;
    };

    void enableXORInput() { timer.CR2.TI1S = 1; }
    void disableXORInput() { timer.CR2.TI1S = 0; }
    void generateEvent(Event event) { timer.EGR = static_cast<uint32_t>(event); }

    void enableCompareOutputs() { timer.BDTR.MOE = 1; }
    uint32_t getValue() { return timer.CNT; }
    void setValue(uint32_t value) { timer.CNT = value; }

    enum class OffStateForRunMode { HiZ_GPIO, InactiveState };
    enum class OffStateForIdleMode { HiZ_GPIO, IdleState };
    void configureOffState(OffStateForRunMode ossr, OffStateForIdleMode ossi) {
        timer.BDTR.OSSR = static_cast<uint32_t>(ossr);
        timer.BDTR.OSSI = static_cast<uint32_t>(ossi);
    }

    void configureMasterMode(MasterMode masterMode) { timer.CR2.MMS = static_cast<uint32_t>(masterMode); }
    void configureSlaveMode(SlaveMode slaveMode, Trigger triggerSource) {
        timer.SMCR.setSMS(static_cast<uint32_t>(slaveMode));
        timer.SMCR.TS = static_cast<uint32_t>(triggerSource);
    }

    OutputCompare compare1;
    OutputCompare compare2;
    OutputCompare compare3;
    OutputCompare compare4;
    InputCapture capture1;

 private:
    TimerRegisterMap &timer;
    Signal<void> signal;
    static Timer *tim3;

    IRQn_Type getIRQn() const {
        if ((TIM_TypeDef *)&timer == TIM1) return TIM1_CC_IRQn;
        if ((TIM_TypeDef *)&timer == TIM3) return TIM3_IRQn;
    }

    friend void TIM3_IRQHandler(void);
};  // namespace stm32f3xx

}  // namespace stm32f3xx
}  // namespace microhal

#endif /* _MICROHAL_TIMER_STM32F3XX_H_ */
